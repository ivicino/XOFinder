# -*- coding: utf-8 -*-
"""X.O.-Finder.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1N1QCddf_-Po0asiTP4uNlYsZ9Z-cbqVZ

#Seperate video into individual images
"""


# Importing all necessary libraries 
import cv2 
import os 
import click
import numpy as np
from os import listdir
import glob

@click.command()
@click.option('--AVI', prompt= True, help="Path to exocytosis .avi file to be processed.", type=click.Path(exists=True, dir_okay=False)) #/Users/ivicino/Documents/PhD material/Research/tirf007.avi
@click.option('--FRAMES', prompt= True, help="Path to location where you want the frames from the .avi file to be deposited. \n Must have a / at the end of the file path. Ex: /Users/ivicino/TEST/", type=click.Path()) #/Users/ivicino/TEST/DATA/
@click.option('--MODFRAMES', prompt= True, help="Path to where you want the tagged frames to be put.", type=click.Path()) #/Users/ivicino/TEST/VIDSAVEDIR
@click.option('--VIDDIR', prompt= True , help="Path to where you want the final video to be found", type=click.Path()) #/Users/ivicino/TEST

def main(avi, viddir, modframes, frames):
    
      
    cam = cv2.VideoCapture(avi) 
    
    #Specifying paths and variable names for paths
    VIDEO_DIR = viddir
    #========================================
    DATA=frames
    #========================================
    
    try: 
    	
       	# creating a folder named data 
       	if not os.path.exists(DATA): 
               os.makedirs(DATA) 
      		
        
        # if not created then raise error 
    except OSError: 
         	print ('Error: Creating directory of data') 
    
    VIDEO_SAVE_DIR = modframes
    #========================================
    try:
    
     	if not os.path.exists(VIDEO_SAVE_DIR):
     			os.makedirs(VIDEO_SAVE_DIR)
    	 
    except OSError:
     	print ('Error: Creating directory of data')
         

        
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   
    
    # frame 
    currentframe = 0
    
    # # with cv2.CAP_PROP_POS_FRAMES, which is a 0-based index of the frame to be decoded/captured next.
    # #this makes the next frame = variable "frame_count" 
    # frame_count=cam.get(cv2.CAP_PROP_POS_FRAMES)
    
    
    while(True): 
    	
    	# reading from frame 
    	ret,frame = cam.read() 
    
    	if ret: 
    		# if video is still left continue creating images 
    		name = DATA + str(currentframe) + '.png' #need to put filepath here, '/data1/'
    		print ('Creating...' + name) 
    
    		# writing the extracted images 
    		cv2.imwrite(name, frame) 
    
    		# increasing counter so that it will 
    		# show how many frames are created 
    		currentframe += 1
    
    
    	else: 
    		break
    
    # Release all space and windows once done 
    cam.release() 
    cv2.destroyAllWindows()
    


    """#Finding exocytosis events in many images
    ##Subtract first frame from rest of frames: (see below code bracketed by ___)
    """
    
    
    mypath=DATA
    files = listdir(mypath)
    
    #Lists needed to run code
    FILES=[]
    Files=[]
    yoo=[]
    LIST=[]
    #----------------------------
    
    #below code used to sort files numerically
    for i in files:
      filez=os.path.splitext(i)[0]  #removes the extension from the filename leaving only the number '0', '1', '2'...
      FILES.append(filez)
    FILES.sort(key = int)           #sorts FILES numerically
    
    #need to put extensions back to filename
    for i in FILES:
      i=os.path.join(i + '.png')
      Files.append(i)               #append a new list with new filenames with appropriate extensions
    
    for f in Files:
      print (f)
      img = os.path.join(mypath,f)
      img2 = cv2.imread(img)
      image = img2
      original = img2.copy()
    
      #OpenCV uses H: 0-179, S: 0-255, V: 0-255 instead of H:0-360, S: 0-100, V: 0-100 as is typically used
      #must use cv2colorpicker.py on my computer to chose the lower and upper color values for the mask. 
      #Using HSV makes it easier for the program to represent colors, and choose which colors to mask. Hopefully this will fix the flickering...
      hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
      lower = np.array([29, 255, 255], dtype="uint8")
      upper = np.array([30, 255, 255], dtype="uint8")
      mask = cv2.inRange(hsv, lower, upper)
    
    
      cnts = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
      cnts = cnts[0] if len(cnts) == 2 else cnts[1] 
    
      #code to delete bounding boxes from first frame. 
      if f=='0.png':
        # yoo.append(cnts)
        cnts=np.asarray([[[[0,0]]]])
      if f=='1.png':
        yoo.append(cnts)
      if f=='2.png':
        yoo.append(cnts)
      if f=='3.png':
        yoo.append(cnts)
      if f=='4.png':
        yoo.append(cnts)
      if f=='5.png':
        yoo.append(cnts)
      if f=='6.png':
        yoo.append(cnts)
      if f=='7.png':
        yoo.append(cnts)
      if f=='8.png':
        yoo.append(cnts)
      if f=='9.png':
        yoo.append(cnts)
      if f=='10.png':
        yoo.append(cnts)
      if f=='11.png':
        yoo.append(cnts)
      if f=='12.png':
        yoo.append(cnts)
      if f=='13.png':
        yoo.append(cnts)
      if f=='14.png':
        yoo.append(cnts)
      if f=='15.png':
        yoo.append(cnts)
      
      else:
        yoo=yoo
        for c in cnts:
          for g in c:
            for x,y in g:
              for q in yoo:
                for t in q:
                  for w in t:
                    for m in w:
                      goo=(x,y)==(m[0],m[1]) 
                      if goo==True:
                        m=[0,0] 
                        g=np.array([list(m)])
                        c=np.array(list(g))
                        
          LIST.append(c)    
          x,y,w,h = cv2.boundingRect(c)
          cv2.rectangle(original, (x, y), (x + w, y + h), (255,191,0), 2)
    
      #Saving Images
      print('saving images...')
      counter = 0
      counter=counter+1
      name = f 
      name = os.path.join(VIDEO_SAVE_DIR, name)
      print('writing to file:{0}'.format(name))
      cv2.imwrite(name, original)
      cv2.waitKey()
    
    """#Make frames into full video"""
    
    def make_video(outvid, images=None, fps=30, size=None,
                   is_color=True, format="FMP4"):
        """
        Create a video from a list of images.
     
        @param      outvid      output video
        @param      images      list of images to use in the video
        @param      fps         frame per second
        @param      size        size of each frame
        @param      is_color    color
        @param      format      see http://www.fourcc.org/codecs.php
        @return                 see http://opencv-python-tutroals.readthedocs.org/en/latest/py_tutorials/py_gui/py_video_display/py_video_display.html
        """
        from cv2 import VideoWriter, VideoWriter_fourcc, imread, resize
        fourcc = VideoWriter_fourcc(*'mp4v')
        vid = None
        for image in images:
            if not os.path.exists(image):
                raise FileNotFoundError(image)
            img = imread(image)
            if vid is None:
                if size is None:
                    size = img.shape[1], img.shape[0]
                vid = VideoWriter(outvid, fourcc, float(fps), size, is_color)
            if size[0] != img.shape[1] and size[1] != img.shape[0]:
                img = resize(img, size)
            vid.write(img)
        vid.release()
        return vid
    

    
    # Directory of images to run detection on
    
    images = list(glob.iglob(os.path.join(VIDEO_SAVE_DIR, '*.*')))
    # Sort the images by integer index
    images = sorted(images, key=lambda x: float(os.path.split(x)[1][:-3]))
    
    outvid = os.path.join(VIDEO_DIR, "exocytosis.mp4")
    make_video(outvid, images, fps=7.0)
    print('Final video made')

if __name__ == '__main__':
    main()